<!DOCTYPE html>
<html>
<body>

    <style>
        body {
            display: flex;
            place-content: center;
        }
        body[data-view="bingo spinner"] #bingo_wrapper,
        body[data-view="amount selector"] #amount_wrapper,
        body[data-view="cards editor"] #card_editor_wrapper,
        body[data-view="card printer"] #printer_wrapper,
        body[data-view="card verify and loader"] #verify_and_loader_wrapper,
        body[data-view="batch card printer"] #batch_printer_wrapper {
            display: flex;
        }

        body[data-view="bingo spinner"] .card_control,
        #amount_wrapper, #bingo_wrapper, #card_editor_wrapper,
        #printer_wrapper, #verify_and_loader_wrapper, #batch_printer_wrapper{
            display: none;
        }

        #amount_wrapper, #bingo_wrapper, #card_editor_wrapper, #printer_wrapper,
        #batch_printer_wrapper {
            touch-action: manipulation;
            flex-direction: column;
            place-items: center;
            text-align: center;
            width: 60%;
        }

        #bingo_wrapper > #number_display {
            font-size: 5vw;
        }

        #start_button{
            margin-top: 2vw;
            font-size: 5vw;
        }

        #content, #number_selector, #active_card {
            display:table;
            width: 100%;
            font-size: 2vw;
            touch-action: manipulation;
            border-collapse: collapse;
            border: 1px solid black;
            text-align: center;
        }
        #number_display {
            margin: 0;
        }
        .top {
            display: grid;
            grid-template-columns: 1fr 1fr;
            position: absolute;
            top: 0;
        }
        .top span {
            padding: 0.5vw 1vw;
            border-bottom: 1px solid black;
        }
        .left {
            left: 0;
            flex-direction: column;
        }
        .left span {
            border-right: 1px solid black;
        }
        .left > * {
            display: flex;
        }
        .right {
            right: 0;
        }
        .right > span {
            border-left: 1px solid black;
        }
        .table_row {
            display: table-row;
            border: 1px solid black;
        }
        .table_cell {
            display: table-cell;
            border: 1px solid black;
            padding: 0;
            vertical-align: middle;
        }
        .chosen {
            background-color: lightgreen;
        }
        .number_input {
            font-size: 10vw;
            width: 1em;
        }
        .row {
            display: flex;
        }

        #cards_wrapper,
        #bingo_wrapper .add_card {
            display: none;
        }

        #card_editor_wrapper > #cards_wrapper,
        #bingo_wrapper > #cards_wrapper {
            touch-action: manipulation;
            display: flex;
        }

        #active_card .table_cell > input {
            width: 5vw;
            border: 0;
            padding: 0;
            outline: none;
            font-size: 2vw;
            text-align: center;
        }

        #card_editor_wrapper > * {
            margin: 1vw;
        }

        #card_editor {
            display: flex;
        }
        .card_button {
            display: flex;
            place-content: center;
            border: black solid;
            margin: 0 1vw;
            width: 5vw;
        }

        .card {
            touch-action: manipulation;
            border: black solid;
            margin: 1vw;
            height: 18vw;
            width: 18vw;
            display:table;
            text-align: center;
            font-size: 2vw;
        }

        .card_control, .card_content {
            display: flex;
            place-content: center;
        }

        .card_control > .card_button {
            margin: 0 0.2vw;
        }

        #card_template, #svg_card_template, #svg_barcode_template {
            display: none;
        }
    </style>

    <div class='top left'>
        <span id='reset_button'>reset</span>
        <span id='change_amount'>change amount</span>
        <span id='spinner_button'>spinner</span>
        <span id='cards_editor_button'>bingo card</span>
        <span id='printer_button'>card printer</span>
        <span id='verify_load_button'>verify/load card</span>
        <span id='batch_printer_button'>batch printer</span>
        </div>
    </div>

    <div class='top right'>
        <span id='mute_button'>mute</span>
        <span id='fullscreen'>fullscreen</span>
    </div>

    <div id='amount_wrapper'>
        <h1>Bingo Number Roller Caller</h1>
        <div id='amount_input'></div>
        <button id='start_button'>Start!</button>
    </div>

    <div id='bingo_wrapper'>
        <h1 id="number_display">Click</h1>
        <div id="content"></div>
    </div>

    <div id='card_editor_wrapper'>
        <h1>Card Editor</h1>
        <div id='card_editor'>
            <div style='display:grid;'>
                <div id='randomize_card_editor' class='card_button'>
                    <svg viewBox='0 0 16 16'>
                        <path d="M1,11 L5,11 L9,5 L14,5 L10,2" stroke="black" fill="none"></path>
                        <path d="M1,5 L5,5 L9,11 L14,11 L10,14" stroke="black" fill="none"></path>
                    </svg>
                </div>
                <div id='clear_card_editor' class='card_button'>
                    <svg viewBox='0 0 16 16'>
                        <path d='M1,8 L15,8' stroke='black' fill='none'></path>
                    </svg>
                </div>
            </div>
            <div id='active_card'></div>
            <div id='add_card_editor' class='card_button'>
                <svg viewBox='0 0 16 16'>
                    <path d='M1,8 L15,8' stroke='black' fill='none'></path>
                    <path d='M8,1 L8,15' stroke='black' fill='none'></path>
                </svg>
            </div>
        </div>
        <div id='number_selector'></div>
    </div>

    <div id='printer_wrapper'>
        <h1>Card Printer</h1>
        <div style='display:flex;'>
            <div id='prev_card' class='card_button'>
                <svg viewBox='0 0 16 16'>
                    <path d="M14,2 L2,8 L 14,14" stroke="black" fill="none"></path>
                </svg>
            </div>
            <div>
                <div id='printer_card' style="text-align: center; display:grid; place-content:center;">
                    <div>
                        <label>Card id: </label><label id='card_id'></label>
                    </div>
                    <div id='card_viewer'></div>
                </div>
                <button id='svg_button'>Svg</button>
                <button id='print_button'>Print</button>
            </div>
            <div id='next_card' class='card_button'>
                <svg viewBox='0 0 16 16'>
                    <path d='M2,2 L14,8 L2,14' stroke='black' fill='none'></path>
                </svg>
            </div>
        </div>
    </div>

    <div id='verify_and_loader_wrapper'>
        <label>Card id:</label><input id='card_loader'>
        <div id='card_loader_viewer'></div>
        <button id='loader_button'>Load</button>
    </div>

    <div id='batch_printer_wrapper'>
        <h1>Batch Card Printer</h1>
        <div>
            <label>Amount of cards:</label><input type="number" id='batch_amount'>
        </div>
        <label>Print cards set:</label>
        <button id='unique_batch_button'>Unique Winners</button>
        <button id='random_batch_button'>Random (chance of multiple winners)</button>
    </div>

    <div id='cards_wrapper'>
    </div>

    <div id='card_template'>
        <div class='card_control'>
            <div class='card_button move_card_left'>
                <svg viewBox='0 0 16 16'>
                    <path d='M14,2 L2,8 L 14,14' stroke='black' fill='none'></path>
                </svg>
            </div>
            <div>
                <div class='card_button edit_card'>
                    <svg viewBox='0 0 16 8'>
                        <path d='M2,6 L8,2 L14,6' stroke='black' fill='none'></path>
                    </svg>
                </div>
                <div class='card_button delete_card'>
                    <svg viewBox='0 0 16 8'>
                        <path d='M2,2 L14,6' stroke='black' fill='none'></path>
                        <path d='M2,6 L14,2' stroke='black' fill='none'></path>
                    </svg>
                </div>
            </div>
            <div class='card_button move_card_right'>
                <svg viewBox='0 0 16 16'>
                    <path d='M2,2 L14,8 L2,14' stroke='black' fill='none'></path>
                </svg>
            </div>
        </div>
        <div class='card_content'></div>
        <label>Card ID: </label><label class='card_id'></label>
    </div>

    <svg viewBox="0 0 252 252" id='svg_card_template' xmlns="http://www.w3.org/2000/svg">
        <g transform="translate(1, 1)">
            <path id='grid_rows' fill="none" stroke="black" stroke-linecap="square"></path>
            <path id='grid_columns' fill="none" stroke="black" stroke-linecap="square"></path>

            <text id='svg_card_id' dominant-baseline="hanging" text-anchor="start" x="2" y="2" style="font-size: 5px;"></text>
            <text id='grid_number' dominant-baseline="middle" text-anchor="middle"></text>
            <g id='grid_numbers'></g>
        </g>
    </svg>

    <svg viewBox="0 0 320 100" id='svg_barcode_template' stroke="black" stroke-width="1" shape-rendering="crispEdges" xmlns="http://www.w3.org/2000/svg" version="1.1" style="margin: max(1vw, 1vh);">
        <line stroke-dasharray="" x1="0" y1=".5" x2="0" y2=".5" transform="matrix(1 0 0 100 0 0)"></line>
    </svg>

    <dialog id='alert'>
        <p></p>
    </dialog>

    <script>
        /*
            cyrb53 (c) 2018 bryc (github.com/bryc)
            A fast and simple hash function with decent collision resistance.
            Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
            Public domain. Attribution appreciated.
        */
        class bryc{
            static cyrb128(str) {
                let h1 = 1779033703, h2 = 3144134277,
                    h3 = 1013904242, h4 = 2773480762;
                for (let i = 0, k; i < str.length; i++) {
                    k = str.charCodeAt(i);
                    h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
                    h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
                    h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
                    h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
                }
                h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
                h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
                h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
                h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
                return [(h1^h2^h3^h4)>>>0, (h2^h1)>>>0, (h3^h1)>>>0, (h4^h1)>>>0];
            }
        }
    </script>
    <script>
        // I, Chris Doty-Humphrey, release all of my work on PractRand to the public domain. 
        // https://pracrand.sourceforge.net/license.txt
        // sfc* was designed and coded by myself, and is public domain.  

        // ported by bryc
        // (c) 2018 bryc (github.com/bryc)
        // Public domain. Attribution appreciated.
        class PractRand{
            static sfc32(a, b, c, d) {
                return function() {
                a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
                var t = (a + b) | 0;
                a = b ^ b >>> 9;
                b = c + (c << 3) | 0;
                c = (c << 21 | c >>> 11);
                d = d + 1 | 0;
                t = t + d | 0;
                c = c + t | 0;
                return (t >>> 0) / 4294967296;
                }
            }
        }
    </script>
    <script>
        // Base on this stackoverflow answer from Rafael Lima
        // Licensed CC BY-SA 4.0 (mentioned in share menu)
        // https://stackoverflow.com/a/69549596/1986995

        // Fixed the edge case bug
        class base_convert{
            static alphabet = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';

            static to_radix = function(bigNum, radix=64) {
                if(typeof bigNum != 'bigint')
                bigNum = BigInt(bigNum);

                radix = BigInt(Math.max(Math.min(radix, this.alphabet.length),0))

                let result = '';
                while (bigNum>0) {
                    let r = bigNum % radix;
                    result = this.alphabet[r] + result;
                    bigNum = bigNum / radix;
                } 
                return result
            }

            static from_radix = function(input, radix=64) {
                if(!input)
                    return 0;

                radix = BigInt(Math.max(Math.min(radix, this.alphabet.length),0))

                var result = 0n;

                for (var i = 0; i < input.length; i++)
                    result = (result * BigInt(radix)) + BigInt(this.alphabet.indexOf(input[i]));

                return result;
            }
        }
    </script>
    <script>
        // Base on this stackoverflow answer marked community wiki
        // Licensed CC BY-SA 4.0 (mentioned in share menu)
        // https://stackoverflow.com/a/6274398/1986995
        function seeded_shuffle(array, seed) {
            let random_generator = PractRand.sfc32(...bryc.cyrb128(seed));
            let counter = array.length;

            // While there are elements in the array
            while (counter > 0) {
                // Pick a random index
                let index = Math.floor(random_generator() * counter);

                // Decrease counter by 1
                counter--;

                // And swap the last element with it
                let temp = array[counter];
                array[counter] = array[index];
                array[index] = temp;
            }

            return array;
        }
    </script>
    <script>
        const View_states = {
            Bingo: 'bingo spinner',
            Amount: 'amount selector',
            Cards: 'cards editor',
            Printer: 'card printer',
            Verify: 'card verify and loader',
            Batch: 'batch card printer'
        };
        Object.freeze(View_states);

        function create_svg_icon(size, path){
            let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg")
            svg.setAttribute('viewBox', size);

            let path_element = document.createElementNS("http://www.w3.org/2000/svg", "path")
            path_element.setAttribute('d',path);
            path_element.setAttribute('stroke','black')
            path_element.setAttribute('fill', 'none')
            path_element.setAttribute('stroke-linejoin', 'round')

            svg.appendChild(path_element);
            return svg
        }

        function shuffle(array) {
            let currentIndex = array.length, temporaryValue, randomIndex;

            // While there remain elements to shuffle...
            while (0 !== currentIndex) {
            // Pick a remaining element...
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex --;

                // And swap it with the current element.
                temporaryValue = array[currentIndex];
                array[currentIndex] = array[randomIndex];
                array[randomIndex] = temporaryValue;
            }
        }

        class SpeechQueue {
            constructor(){
                this._queue = [];
                this.speaking = false;
            }

            queue(text){
                this._queue.unshift(text);
                this.speak();
            }

            speak(){
                if (this.speaking || !this._queue.length) return
                this.speaking = true;
                let text = this._queue.pop();
                let utter = new SpeechSynthesisUtterance(text);
                utter.onend = ()=>{
                    setTimeout(()=>{
                        this.speaking = false;
                        this.speak();
                    }, 300)
                }
                speechSynthesis.speak(utter);
            }

            cancel(){
                this._queue.length = 0;
                speechSynthesis.cancel();
            }
        }

        let speechqueue = new SpeechQueue();

        class Roll {
            constructor(bingo, number_elements){
                this.bingo = bingo;
                this.end_roll_time;
                shuffle(number_elements);
                this.numbers = number_elements;
                this.spinning = false;
            }

            unroll_element(element){
                element.classList.remove("chosen");
                let number = element.textContent;
                this.bingo.cards.unroll(number);
                this.numbers.push(element);
                shuffle(this.numbers);
            }

            roll(number, muted){
                let number_display = document.getElementById('number_display');
                number_display.textContent = number;

                if (!muted) {
                    number = parseInt(number).toString();
                    for (let text of [number, ...number]){
                        speechqueue.queue(text);
                    }
                }
            }

            roll_element(element, muted){
                if (muted === undefined)
                    muted = this.bingo.muted
                element.classList.add('chosen');
                this.numbers.splice(this.numbers.indexOf(element), 1);
                let number = element.textContent;
                this.roll(number, muted);
                this.bingo.cards.roll(number);
            }

            animated_roll(){
                if (!this.numbers.length){
                    this.spinning = false;
                    return
                }

                let number;
                if (performance.now() < this.end_roll_time){
                    let index = Math.floor(Math.random() * this.numbers.length);
                    number = this.numbers[index].textContent;
                    this.roll(number, true);
                    requestAnimationFrame(()=>this.animated_roll());
                } else {
                    let element = this.numbers[0];
                    this.spinning = false;
                    this.roll_element(element);
                }


            }
            start_animated_roll(){
                if (this.spinning) return
                this.spinning = true;
                if (this.numbers.length > 1) this.end_roll_time = performance.now()+1500;
                this.animated_roll();
            }
        }

        class Bingo{
            constructor(){
                this.inputs = [];
                this.muted = false;
                this.roll_instance;
                this.url = new URL(window.location.href);
                this.cards = new Cards(this);
                this.cards.observe();
                this.printer = new Printer(this);
                this.loader = new Loader(this);
                this.init_ui()
                this.post_init_ui();
            }

            bind_input_handler(up, input, down){
                // Set outer `last_input` to local next_input
                // So it doesn't change for the local scope
                let next_input = this.inputs[this.inputs.length-1];
                let check_input = function(){
                    // If less than 0, decrease next number
                    while (input.value < 0) {
                        input.value = +input.value + 10;
                        if (next_input){
                            next_input.stepDown()
                            next_input.oninput()
                        };
                    }
                    // If more than 9, increase next number
                    while (input.value > 9) {
                        input.value = +input.value - 10;
                        if (next_input){
                            next_input.stepUp();
                            next_input.oninput()
                        }
                    }
                }
                input.oninput = check_input;
                up.onclick = ()=>{input.stepUp(); input.oninput()};
                down.onclick = ()=>{input.stepDown(); input.oninput()};

                this.inputs.push(input);
            }

            create_input_number(){
                let up, input, down;

                up = create_svg_icon('0 0 16 8', 'M1,7 L8,1 L15,7'); //'︿'

                input = document.createElement('input');
                input.classList.add('number_input');
                input.type='number';
                input.value = 0;

                down = create_svg_icon('0 0 16 8', 'M1,1 L8,7 L15,1'); //'﹀'

                this.bind_input_handler(up, input, down)

                return [up, input, down];
            }

            generate_amount_input(){
                let amount_input = document.getElementById('amount_input');

                let columns = [];
                let rows = [];

                // Create the three row, up button row, input row, down button row
                for (let i=0; i<3; i++){
                    let row = document.createElement('div');
                    row.classList.add('row');
                    rows.push(row)
                }

                // create the amount of input wanted
                let max_number = 999
                let number_of_digit = Math.log10(max_number)+1|0
                for (let i=0; i<number_of_digit; i++){
                    let number_column = this.create_input_number();
                    columns.push(number_column);
                }

                // columns to rows
                // layman terms: for first row, append first item in columns, etc etc
                for (let i=0; i<rows.length; i++){
                    for (let column of columns){
                        rows[i].appendChild(column[i])
                    }
                }

                // Append each row to the amount input interface
                for (let row of rows){
                    amount_input.appendChild(row);
                }
            }

            generate_numbers_display(numbers){
                let content = document.getElementById('content')
                content.innerHTML = '';
                let number = 0 ;
                let number_elements = [];
                let number_length = Math.floor(Math.log10(numbers)) + 1;

                while (number < numbers){
                    let row = document.createElement('div')
                    row.classList.add('table_row');
                    for (let i=0; i<10; i++){
                        number++;
                        if (number > numbers) break;
                        let span = document.createElement('span');
                        span.textContent = number.toString().padStart(number_length, '0');
                        span.classList.add('table_cell');
                        span.onclick = ()=>{
                            if (span.classList.contains("chosen")){
                                this.roll_instance.unroll_element(span);
                            } else {
                                this.roll_instance.roll_element(span);
                            }
                        };
                        row.appendChild(span);
                        number_elements.push(span);
                    }
                    content.appendChild(row);
                }

                return number_elements;
            }

            get_input_number(){
                let res = "";
                for (let input of this.inputs){
                    res += input.value;
                }
                return parseInt(res);
            }

            update_url(){
                this.url.searchParams.set("amount", this.get_input_number());
                window.history.replaceState('', '', this.url.href);
            }

            start(){
                this.update_url();
                this.cards.reset();
                let number_elements = this.generate_numbers_display(this.get_input_number());
                this.roll_instance = new Roll(this, number_elements);
                document.body.dataset.view=View_states.Bingo;
                let number_display = document.getElementById('number_display');
                number_display.textContent = 'Click';
            }

            change_amount(){
                document.body.dataset.view=View_states.Amount;
            }

            cards_editor(){
                this.update_url();
                document.body.dataset.view=View_states.Cards;
            }

            bingo_spinner(){
                document.body.dataset.view=View_states.Bingo;
            }

            printer_button(){
                this.printer.update_ui();
                document.body.dataset.view=View_states.Printer;
            }

            verify_and_loader(){
                document.body.dataset.view=View_states.Verify;
            }

            batch_printer_button(){
                document.body.dataset.view=View_states.Batch;
            }

            mute(){
                let mute_button = document.getElementById('mute_button');
                if (!this.muted){
                    speechqueue.cancel();
                    this.muted = true;
                    mute_button.style['background-color'] = 'red';
                } else {
                    this.muted = false;
                    mute_button.style['background-color'] = '';
                }
            }

            init_ui(){
                let mute_button = document.getElementById('mute_button');
                mute_button.onclick = ()=>this.mute();

                let fullscreen_button = document.getElementById('fullscreen');
                fullscreen_button.onclick = function(){
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        document.documentElement.requestFullscreen();
                    }
                }

                let alert = document.getElementById('alert');
                alert.onclick = ()=>alert.close();

                this.generate_amount_input();
                let last_input = this.inputs[this.inputs.length-1];
                last_input.value = this.url.searchParams.get("amount") || 90;
                last_input.oninput();

                let start_button = document.getElementById('start_button');
                start_button.onclick = ()=>this.start();

                let reset_button = document.getElementById('reset_button');
                reset_button.onclick = ()=>this.start();

                let change_amount_button = document.getElementById('change_amount');
                change_amount_button.onclick = ()=>this.change_amount();

                let cards_editor_button = document.getElementById('cards_editor_button');
                cards_editor_button.onclick = ()=>this.cards_editor();

                let spinner_button = document.getElementById('spinner_button');
                spinner_button.onclick = ()=>this.bingo_spinner();

                let printer_button = document.getElementById('printer_button');
                printer_button.onclick = ()=>this.printer_button();

                let verify_load_button = document.getElementById('verify_load_button');
                verify_load_button.onclick = ()=>this.verify_and_loader();

                let batch_printer_button = document.getElementById('batch_printer_button');
                batch_printer_button.onclick = ()=>this.batch_printer_button();

                let roll_button = document.getElementById('number_display');
                roll_button.onclick = ()=>this.roll_instance.start_animated_roll();
            }

            post_init_ui(){
                this.start();
                document.body.dataset.view=View_states.Amount;
            }
        }

        class Cards{
            constructor(bingo){
                this.bingo = bingo;
                this.width = 5;
                this.height = 5;
                this.slots = this.width*this.height;
                this.init_ui();
            }

            serializer = {
                to_arrays: function (c){return function* _(){
                    for (let row of c.getElementsByClassName('table_row')){
                        yield function* (r){
                            for (let span of r.getElementsByTagName('span')){
                                let number = span.textContent;
                                if (number === "*")
                                    number = '0'
                                yield parseInt(number);
                            }
                        }(row);
                    };
                }()},

                to_card_id: (card)=>{
                    let data = '';
                    let numbers = [];
                    let max_number = 0;
                    
                    for (let row of card){
                        for (let number of row){
                            numbers.push(number);

                            if (number > max_number)
                                max_number = number;
                        }
                    }

                    let digits = Math.floor(Math.log10(max_number)) + 1;
                    for (let number of numbers){
                        data += number.toString().padStart(digits, '0');
                    }
                    return base_convert.to_radix(data);

                },

                from_card_id: (card_id)=>{
                    alert(card_id.split(/(?:\s+)/).length);
                    if (card_id.startsWith("CS-")){
                        // TODO
                    } else if (card_id.split(/(?:\s+)/).length == this.slots) {
                        // number of numbers match expected bingo card
                        // for support of using google len or OCR to load physical card
                        alert(card_id);
                    } else {
                        //alert(card_id);
                    }
                },

                compact: (card)=>{
                    let data = 0n;
                    let numbers = [];
                    let max_number = 0n;
                    for (let row of card){
                        for (let number of row){
                            number = BigInt(number);
                            numbers.push(number);

                            if (number > max_number)
                                max_number = number;
                        }
                    }

                    max_number += 1n
                    for (let number of numbers){
                        data = data * max_number + number;
                    }

                    return max_number.toString()+"d"+data.toString()
                },

                uncompact: (data)=>{
                    let [max_digit, ...data_array] = data.split('d');
                    max_digit = BigInt(max_digit);
                    let bigNum = BigInt(data_array.join(''));

                    let result = [];
                    while (bigNum>0) {
                        result.push(bigNum % max_digit);
                        bigNum = bigNum / max_digit;
                    }

                    return result.reverse();
                },

            }

            to_arrays_with_seed(card){
                let card_id = card.getElementsByClassName('card_id')[0].textContent;
                return [card_id, this.serializer.to_arrays(card.getElementsByClassName('card')[0])]
            }

            get_cards(){
                let cards_wrapper = document.getElementById('cards_wrapper');
                let cards = cards_wrapper.children;
                return Array.from(cards).map(this.to_arrays_with_seed.bind(this));
            }

            generate_active_card(){
                let active_card = document.getElementById('active_card');

                for (let i=0; i<this.height; i++){
                    let row = document.createElement('div');
                    row.classList.add('table_row');
                    for (let l=0; l<this.width; l++){
                        let input_div = document.createElement('div');
                        let input = document.createElement('input');
                        input_div.appendChild(input);
                        input_div.classList.add('table_cell');
                        input_div.onclick = ()=>input.focus();
                        row.appendChild(input_div);
                    }
                    active_card.appendChild(row);
                }
            }

            arr_2d_to_3d(arr, length){
                let arr_3d = Array(length).fill().map(()=>[]);
                arr.forEach((x,i)=>arr_3d[i%length].push(x))

                return arr_3d
            }

            arr_3d_to_2d(arr){
                if (arr.flat){
                    return arr.flat();
                }

                let out = [];
                for (let row of arr){
                    for (let item of row){
                        out.push(item);
                    }
                }
                return out;
            }

            get_winning_combination_2d(arr){
                // TODO: look into supporting any sized card
                // replace 5 with height/width of card
                let winning = Array(12).fill().map(() => []);

                arr.map((number, i) => {
                    // rows
                    winning[Math.floor(i/5)].push(number)
                    // columns
                    winning[5+(i % 5)].push(number)
                    // diagonal
                    let n = i + 1
                    // if (n in [1, 7, 13, 19, 25])
                    if (((n - Math.ceil(n/5)) % 5) == 0){
                        winning[10].push(number)
                    }
                    // if (n in [5, 9, 13, 17, 21])
                    if (((n + Math.ceil(n/5-1)) % 5) == 0){
                        winning[11].push(number)
                    }
                })

                return winning
            }

            randomize_array(seed, input_numbers){
                input_numbers = input_numbers || this.bingo.get_input_number();
                let numbers = [];
                for (let i=1; i<= input_numbers; i++){
                    numbers.push(i);
                }

                seeded_shuffle(numbers, seed);
                return numbers
            }

            randomize_card(){
                let seed = Math.floor(Math.random()*9999).toString();
                let amount = this.bingo.get_input_number();
                let numbers = this.randomize_array(seed, amount);
                let card_id = "CS"+amount+"-"+seed;

                return {numbers, card_id}
            }
            randomize_active_card(){
                let {numbers, card_id} = this.randomize_card();
                let card_id_element = document.getElementById('card_id');
                card_id_element.textContent = card_id;

                let index = 0;
                let active_card = document.getElementById('active_card');
                for (let input of active_card.getElementsByTagName('input')){
                        input.value = numbers[index];
                        index++;
                }
            }

            clear_active_card(){
                let active_card = document.getElementById('active_card');
                for (let input of active_card.getElementsByTagName('input')){
                        input.value = '';
                }
            }

            load_card_to_editor(card){
                let alert = document.getElementById('alert');
                let active_card = document.getElementById('active_card');
                let inputs = active_card.getElementsByTagName('input');
                for (let input of inputs){
                        if (input.value !== ''){
                            alert.getElementsByTagName('p')[0].textContent = "Card editor is not empty";
                            alert.showModal();
                            return
                        }
                }

                let index = 0;
                for (let span of card.getElementsByTagName('span')){
                    inputs[index].value = span.textContent;
                    index++
                }

                card.parentElement.parentElement.remove();
            }

            generate_card(arr){
                let alert = document.getElementById('alert');
                let card = document.createElement('div');
                card.classList.add('card');

                let index = 0;
                for (let i=0; i<this.height; i++){
                    let row = document.createElement('div');
                    row.classList.add('table_row');
                    for (let l=0; l<this.width; l++){
                        let span = document.createElement('span');
                        let value = arr[index];
                        if (value === '' || value === '*' || value === '0'){
                            span.textContent = '*';
                        } else if (!isNaN(parseInt(value))) {
                            if (parseInt(value) < 0){
                                alert.getElementsByTagName('p')[0].textContent = "Card editor contains a number less than 1";
                                alert.showModal();
                                return
                            } else if (parseInt(value) > this.bingo.get_input_number()){
                                alert.getElementsByTagName('p')[0].textContent = "Card editor contains a number greater than "+this.bingo.get_input_number();
                                alert.showModal();
                                return
                            } else {
                                span.textContent = value;
                            }
                        } else {
                            alert.getElementsByTagName('p')[0].textContent = "Card editor contains non number";
                            alert.showModal();
                            return
                        }
                        
                        span.onclick = ()=>this.click_roll(span);
                        span.classList.add('table_cell');
                        row.appendChild(span);
                        index++;
                    }
                    card.appendChild(row);
                }

                return card
            }

            generate_svg(arr){
                let card_svg = document.getElementById('svg_card_template');
                let copy = card_svg.cloneNode(true);

                let rows = copy.getElementById('grid_rows');
                rows.setAttribute('d', "M 250 -50 " + "m -250 50 l 250 0".repeat(6));

                let columns = copy.getElementById('grid_columns');
                columns.setAttribute('d', "M -50 250 " + "m 50 -250 l 0 250".repeat(6));

                let number_grid = copy.getElementById('grid_numbers');

                let number = copy.getElementById('grid_number');

                let i = 0
                for (let row = 0; row < 5; row++){
                    for (let column = 0; column < 5; column++){
                        let number_copy = number.cloneNode();
                        number_copy.setAttribute('x', column * 50 + 25);
                        number_copy.setAttribute('y', row * 50 + 25);
                        number_copy.textContent = arr[i];
                        number_grid.appendChild(number_copy);
                        i+=1
                    }
                }

                return copy
            }

            generate_and_add_card(){
                let card_template = document.getElementById('card_template');

                let active_card = document.getElementById('active_card');
                let inputs = active_card.getElementsByTagName('input');
                let arr = Array.from(inputs).map((x)=>x.value);
                let card = this.generate_card(arr)

                let card_wrapper = card_template.cloneNode(true);
                card_wrapper.removeAttribute('id');
                let card_content = card_wrapper.getElementsByClassName('card_content')[0];
                card_content.appendChild(card);

                let move_left = card_wrapper.getElementsByClassName('move_card_left')[0];
                move_left.onclick = ()=>card_wrapper.parentElement.insertBefore(card_wrapper, card_wrapper.previousSibling);
                let move_right = card_wrapper.getElementsByClassName('move_card_right')[0];
                move_right.onclick = ()=>{
                    if (card_wrapper.nextSibling) {
                        card_wrapper.parentElement.insertBefore(card_wrapper, card_wrapper.nextSibling.nextSibling);
                    } else {
                        card_wrapper.parentElement.prepend(card_wrapper);
                    }
                    
                };
                let edit_button = card_wrapper.getElementsByClassName('edit_card')[0];
                edit_button.onclick = ()=>this.load_card_to_editor(card);
                let delete_button = card_wrapper.getElementsByClassName('delete_card')[0];
                delete_button.onclick = ()=>card_wrapper.remove();

                // Verify seeded random number isn't edited
                let card_id = document.getElementById('card_id');
                let card_id_regex = /CS\d+-(\d+)/
                if (card_id_regex.test(card_id.textContent)){
                    let all_match = true;
                    let ra = this.randomize_array(card_id.textContent.match(card_id_regex)[1]);
                    for (let i=0; i<inputs.length; i++){
                        let value = inputs[i].value;
                        if (value === '' || value === '*' || ra[i] != parseInt(value)){
                            all_match = false;
                            break;
                        }
                    }

                    if (all_match){
                        card_wrapper.getElementsByClassName('card_id')[0].textContent = card_id.textContent;
                    }

                }

                return card_wrapper;
            }

            mark_rolled_number(card){
                let content = document.getElementById('content');
                let rolled = new Set();
                rolled.add("*");
                for (let chosen of content.getElementsByClassName('chosen')){
                    rolled.add(parseInt(chosen.textContent));
                }

                for (let slot of card.getElementsByTagName('span')){
                    let value = !isNaN(parseInt(slot.textContent)) ? parseInt(slot.textContent) : slot.textContent;
                    if (rolled.has(value)){
                        slot.classList.add('chosen');
                    }
                }
            }

            add_card(){
                let cards = document.getElementById('cards_wrapper');
                let card_wrapper = this.generate_and_add_card();
                this.mark_rolled_number(card_wrapper);

                cards.appendChild(card_wrapper);
                this.clear_active_card();
            }

            init_ui(){
                this.generate_active_card();

                let active_card = document.getElementById('active_card');

                let random_button = document.getElementById('randomize_card_editor');
                random_button.onclick = ()=>this.randomize_active_card();
                let clear_button = document.getElementById("clear_card_editor");
                clear_button.onclick = ()=>this.clear_active_card();

                let add_button = document.getElementById('add_card_editor');
                add_button.onclick = ()=>this.add_card();
            }

            update_ui(){
                let content = document.getElementById('number_selector');
                content.innerHTML = '';
                let number = 0;
                let numbers = this.bingo.get_input_number();
                let number_elements = [];
                let number_length = Math.floor(Math.log10(numbers)) + 1;

                while (number < numbers){
                    let row = document.createElement('div');
                    row.classList.add('table_row');
                    for (let i=0; i<10; i++){
                        number++;
                        if (number > numbers) break;
                        let span = document.createElement('span');
                        span.textContent = number.toString().padStart(number_length, '0');
                        span.classList.add('table_cell');
                        // allow clicking number to fill the next empty slot
                        span.onclick = ()=>{
                            let active_card = document.getElementById('active_card');
                            for (let input of active_card.getElementsByTagName('input')){
                                if (input.value === ''){
                                    input.value = span.textContent;
                                    return
                                }
                            }
                        };
                        row.appendChild(span);
                        number_elements.push(span);
                    }
                    content.appendChild(row);
                }

                return number_elements;
            }

            reset(){
                let cards = document.getElementById('cards_wrapper');
                let slots = cards.getElementsByClassName('chosen');
                while (slots.length){
                    slots[0].classList.remove('chosen');
                }
            }

            unroll(number){
                let cards = document.getElementById('cards_wrapper');
                for (let slot of cards.getElementsByTagName('span')){
                    if (parseInt(slot.textContent) == parseInt(number)){
                        slot.classList.remove('chosen');
                    }
                }
            }
            roll(number){
                let cards = document.getElementById('cards_wrapper');
                for (let slot of cards.getElementsByTagName('span')){
                    if (parseInt(slot.textContent) == parseInt(number)){
                        slot.classList.add('chosen');
                    }
                }
            }

            click_roll(element){
                if (isNaN(parseInt(element.textContent))) return;
                for (let span of document.getElementById('content').getElementsByTagName('span')){
                    if (parseInt(span.textContent) == parseInt(element.textContent)){
                        span.click();
                    }
                }
            }

            observe(){
                const cards_element = document.getElementById('cards_wrapper');
                const config = { attributes: true, childList: false, subtree: false };

                // Callback function to execute when mutations are observed
                const callback = (mutationList, observer) => {
                    for (const mutation of mutationList) {
                        if (mutation.type === 'attributes' & mutation.attributeName==="data-view") {
                            if (mutation.target.dataset.view === View_states.Bingo){
                                document.getElementById('bingo_wrapper').appendChild(cards_element);
                            } else if (mutation.target.dataset.view == View_states.Cards){
                                document.getElementById('card_editor_wrapper').appendChild(cards_element);
                                this.update_ui();
                            }
                        }
                    }
                };

                // Create an observer instance linked to the callback function
                this.observer = new MutationObserver(callback);

                // Start observing the target node for configured mutations
                this.observer.observe(document.body, config);
            }
        }

        class Printer{
            constructor(bingo){
                this.bingo = bingo;
                this.init_ui();
            }

            Batcher = class Batcher{
                constructor(bingo){
                    this.bingo = bingo;
                    this.global_winning = new Set();
                }

                generate(amount){
                    // let us at least guarantee each card is unique
                    // return Array(amount).fill().map(()=>this.bingo.cards.randomize_card());
                    let selected = [];
                    while (selected.length < amount){
                        let {numbers, card_id} = this.bingo.cards.randomize_card();
                        if (!this.global_winning.has(card_id)){
                            this.global_winning.add(card_id);
                            selected.push({numbers, card_id});
                        }
                    }
                    this.global_winning.clear();
                    return selected
                }

                generate_unique_winners(amount){
                    let number_length = Math.floor(Math.log10(this.bingo.get_input_number())) + 1;
                    let selected = [];
                    while (selected.length < amount){
                        let {numbers, card_id} = this.bingo.cards.randomize_card();
                        let winning = this.bingo.cards.get_winning_combination_2d(numbers.slice(0,25));
                        let serialized = winning.map((w)=>w.toSorted().map((x)=>x.toString().padStart(number_length,'0')).join(''));
                        if (serialized.every((x)=>!this.global_winning.has(x))){
                            serialized.forEach((x)=>this.global_winning.add(x));
                            selected.push({numbers, card_id});
                        }
                    }
                    this.global_winning.clear();
                    return selected
                }
            }

            init_ui(){
                let print_button = document.getElementById('print_button');
                print_button.onclick = ()=>{
                    this.print();
                }
                let svg_button = document.getElementById('svg_button');
                svg_button.onclick = ()=>{
                    this.svg();
                }
                let random_batch_button = document.getElementById('random_batch_button');
                random_batch_button.onclick = ()=>{
                    this.random_batch();
                }
                let unique_batch_button = document.getElementById('unique_batch_button');
                unique_batch_button.onclick = ()=>{
                    this.unique_batch();
                }
                
            }

            random_batch(){
                let batcher = new this.Batcher(this.bingo);
                let cards = batcher.generate(parseInt(document.getElementById('batch_amount').value));
                this.print_batch(cards);
            }

            unique_batch(){
                let batcher = new this.Batcher(this.bingo);
                let cards = batcher.generate_unique_winners(parseInt(document.getElementById('batch_amount').value));
                this.print_batch(cards);
            }

            print_batch(cards){
                let batch_cards = [];
                for (let card of cards){
                    let {numbers, card_id} = card;
                    this.load([card_id, this.bingo.cards.arr_2d_to_3d(numbers.slice(0,25), 5)]);
                    let printer_card = document.getElementById("printer_card").cloneNode(true);
                    let card_div = printer_card.children[1].children[0];
                    card_div.style.width = '98vw';
                    card_div.style.height = '98vh';
                    card_div.style.display='table';
                    card_div.style['table-layout'] = 'fixed';

                    let card_id_element = printer_card.children[0];
                    card_id_element.style.position = 'relative';
                    card_id_element.style['text-align'] = 'start';
                    card_id_element.style['font-size'] = '2vw';
                    card_id_element.style.height = '0';
                    card_id_element.style.top = '1vh';
                    card_id_element.style.left = '2vw';
                    batch_cards.push(printer_card.outerHTML);
                }
                var a = window.open('', '', 'height=500, width=500');
                a.document.write('<html><body>'+batch_cards.join('<div style="break-after:page"></div>')+'</body></html>');
                a.document.close();
                a.print();
            }

            print(){
                var divContents = document.getElementById("printer_card").outerHTML;
                var a = window.open('', '', 'height=500, width=500');
                a.document.write('<html><body>'+divContents+'</body></html>');
                let card = a.document.getElementById('card_viewer').children[0];
                card.style.width = '98vw'
                card.style.height = '98vh'
                card.style.display='table';
                card.style['table-layout'] = 'fixed'
                
                let card_id = a.document.getElementById('card_id').parentElement
                card_id.style.position = 'absolute';
                card_id.style.top = '1vh';
                card_id.style.left = '2vw';
                a.document.close();
                a.print();
            }

            svg(){
                let printer_card = document.getElementById('printer_card');
                let card_id = document.getElementById('card_id').textContent;
                let arr = Array(...printer_card.getElementsByTagName('span')).map((x)=>x.textContent);
                let svg = this.bingo.cards.generate_svg(arr);
                svg.getElementById('svg_card_id').textContent = card_id;
                const as_text = new XMLSerializer().serializeToString(svg);
                // store in a Blob
                const blob = new Blob([as_text], { type: "image/svg+xml" });
                // create an URI pointing to that blob
                const url = URL.createObjectURL(blob);
                let a = document.createElement('a');
                a.href = url;
                a.download = card_id + '.svg';
                a.click();
                // so the Garbage Collector can collect the blob
                URL.revokeObjectURL(url);
            }

            update_ui(){
                let cards = this.bingo.cards.get_cards();

                if (cards.length === 0) {
                    let card_viewer = document.getElementById('card_viewer');
                    card_viewer.textContent = "No card added yet";
                } else {
                    this.load(cards[0]);
                }
            }

            load(card){
                let [card_id_str, card_content_factory] = card;
                if (card_id_str == "")
                    card_id_str = this.bingo.cards.serializer.to_card_id(card_content_factory());

                let card_id = document.getElementById('card_id');
                card_id.textContent = card_id_str;

                let arr = [];
                for (let row of card_content_factory)
                    for (let number of row)
                        arr.push(number.toString());

                let card_ele = this.bingo.cards.generate_card(arr);
                card_ele.style['font-size'] = '6vw'
                for (let row of card_ele.children){
                    row.style.display = 'table-row';
                    row.style.border = '1px black solid';
                    for (let c of row.children){
                        c.style.display = 'table-cell';
                        c.style.border = '1px black solid';
                        c.style.padding = '1vw';
                        c.style['vertical-align'] = 'middle';
                    }
                }

                document.getElementById('card_viewer').innerHTML = card_ele.outerHTML;
            }

        }

        class Barcode{
            // start/stop: "100101101101"
            code39 = {}

            code39_raw = [
                [" ", "100110101101"],
                ["$", "100100100101"],
                ["%", "101001001001"],
                ["+", "100101001001"],
                ["-", "100101011011"],
                ["/", "100100101001"],
                [".", "110010101101"],
                ["0", "101001101101"],
                ["1", "110100101011"],
                ["2", "101100101011"],
                ["3", "110110010101"],
                ["4", "101001101011"],
                ["5", "110100110101"],
                ["6", "101100110101"],
                ["7", "101001011011"],
                ["8", "110100101101"],
                ["9", "101100101101"],
                ["A", "110101001011"],
                ["B", "101101001011"],
                ["C", "110110100101"],
                ["D", "101011001011"],
                ["E", "110101100101"],
                ["F", "101101100101"],
                ["G", "101010011011"],
                ["H", "110101001101"],
                ["I", "101101001101"],
                ["J", "101011001101"],
                ["K", "110101010011"],
                ["L", "101101010011"],
                ["M", "110110101001"],
                ["N", "101011010011"],
                ["O", "110101101001"],
                ["P", "101101101001"],
                ["Q", "101010110011"],
                ["R", "110101011001"],
                ["S", "101101011001"],
                ["T", "101011011001"],
                ["U", "110010101011"],
                ["V", "100110101011"],
                ["W", "110011010101"],
                ["X", "100101101011"],
                ["Y", "110010110101"],
                ["Z", "100110110101"],
            ]

            code128 = {
                "a": {},
                "b": {},
                "c": {},
                // for reversing the pattern to it's value/index and back
                "p_i": {},
                "i_p": {}
            }

            code128_raw = [
                [[" ", " ", "00"], "11011001100"],
                [["!", "!", "01"], "11001101100"],
                [["\"", "\"", "02"], "11001100110"],
                [["#", "#", "03"], "10010011000"],
                [["$", "$", "04"], "10010001100"],
                [["%", "%", "05"], "10001001100"],
                [["&", "&", "06"], "10011001000"],
                [["'", "'", "07"], "10011000100"],
                [["(", "(", "08"], "10001100100"],
                [[")", ")", "09"], "11001001000"],
                [["*", "*", "10"], "11001000100"],
                [["+", "+", "11"], "11000100100"],
                [[", ", ", ", "12"], "10110011100"],
                [["-", "-", "13"], "10011011100"],
                [[".", ".", "14"], "10011001110"],
                [["/", "/", "15"], "10111001100"],
                [["0", "0", "16"], "10011101100"],
                [["1", "1", "17"], "10011100110"],
                [["2", "2", "18"], "11001110010"],
                [["3", "3", "19"], "11001011100"],
                [["4", "4", "20"], "11001001110"],
                [["5", "5", "21"], "11011100100"],
                [["6", "6", "22"], "11001110100"],
                [["7", "7", "23"], "11101101110"],
                [["8", "8", "24"], "11101001100"],
                [["9", "9", "25"], "11100101100"],
                [[":", ":", "26"], "11100100110"],
                [[";", ";", "27"], "11101100100"],
                [["<", "<", "28"], "11100110100"],
                [["=", "=", "29"], "11100110010"],
                [[">", ">", "30"], "11011011000"],
                [["?", "?", "31"], "11011000110"],
                [["@", "@", "32"], "11000110110"],
                [["A", "A", "33"], "10100011000"],
                [["B", "B", "34"], "10001011000"],
                [["C", "C", "35"], "10001000110"],
                [["D", "D", "36"], "10110001000"],
                [["E", "E", "37"], "10001101000"],
                [["F", "F", "38"], "10001100010"],
                [["G", "G", "39"], "11010001000"],
                [["H", "H", "40"], "11000101000"],
                [["I", "I", "41"], "11000100010"],
                [["J", "J", "42"], "10110111000"],
                [["K", "K", "43"], "10110001110"],
                [["L", "L", "44"], "10001101110"],
                [["M", "M", "45"], "10111011000"],
                [["N", "N", "46"], "10111000110"],
                [["O", "O", "47"], "10001110110"],
                [["P", "P", "48"], "11101110110"],
                [["Q", "Q", "49"], "11010001110"],
                [["R", "R", "50"], "11000101110"],
                [["S", "S", "51"], "11011101000"],
                [["T", "T", "52"], "11011100010"],
                [["U", "U", "53"], "11011101110"],
                [["V", "V", "54"], "11101011000"],
                [["W", "W", "55"], "11101000110"],
                [["X", "X", "56"], "11100010110"],
                [["Y", "Y", "57"], "11101101000"],
                [["Z", "Z", "58"], "11101100010"],
                [["[", "[", "59"], "11100011010"],
                [["\\", "\\", "60"], "11101111010"],
                [["]", "]", "61"], "11001000010"],
                [["^", "^", "62"], "11110001010"],
                [["_", "_", "63"], "10100110000"],
                [[String.fromCharCode(0), "", "64"], "10100001100"],
                [[String.fromCharCode(1), "a", "65"], "10010110000"],
                [[String.fromCharCode(2), "b", "66"], "10010000110"],
                [[String.fromCharCode(3), "c", "67"], "10000101100"],
                [[String.fromCharCode(4), "d", "68"], "10000100110"],
                [[String.fromCharCode(5), "e", "69"], "10110010000"],
                [[String.fromCharCode(6), "f", "70"], "10110000100"],
                [[String.fromCharCode(7), "g", "71"], "10011010000"],
                [[String.fromCharCode(8), "h", "72"], "10011000010"],
                [[String.fromCharCode(9), "i", "73"], "10000110100"],
                [[String.fromCharCode(10), "j", "74"], "10000110010"],
                [[String.fromCharCode(11), "k", "75"], "11000010010"],
                [[String.fromCharCode(12), "l", "76"], "11001010000"],
                [[String.fromCharCode(13), "m", "77"], "11110111010"],
                [[String.fromCharCode(14), "n", "78"], "11000010100"],
                [[String.fromCharCode(15), "o", "79"], "10001111010"],
                [[String.fromCharCode(16), "p", "80"], "10100111100"],
                [[String.fromCharCode(17), "q", "81"], "10010111100"],
                [[String.fromCharCode(18), "r", "82"], "10010011110"],
                [[String.fromCharCode(19), "s", "83"], "10111100100"],
                [[String.fromCharCode(20), "t", "84"], "10011110100"],
                [[String.fromCharCode(21), "u", "85"], "10011110010"],
                [[String.fromCharCode(22), "v", "86"], "11110100100"],
                [[String.fromCharCode(23), "w", "87"], "11110010100"],
                [[String.fromCharCode(24), "x", "88"], "11110010010"],
                [[String.fromCharCode(25), "y", "89"], "11011011110"],
                [[String.fromCharCode(26), "z", "90"], "11011110110"],
                [[String.fromCharCode(27), "{", "91"], "11110110110"],
                [[String.fromCharCode(28), "|", "92"], "10101111000"],
                [[String.fromCharCode(29), "}", "93"], "10100011110"],
                [[String.fromCharCode(30), "~", "94"], "10001011110"],
                [[String.fromCharCode(31), "", "95"], "10111101000"],

                // Control pattern onwards
                // not really intend for use in this webapp
                // but included for completeness

                // FNC3
                [[96, 96, "96"], "10111100010"],
                // FNC2
                [[97, 97, "97"], "11110101000"],
                // SHIFT B, Shift A
                [[98, 98, "98"], "11110100010"],
                // Code C
                [[99, 99, "99"], "10111011110"],
                // Code B, FNC 4, Code B
                [[100, 100, 100], "10111101110"],
                // FNC 4, Code A, Code A
                [[101, 101, 101], "11101011110"],
                // FNC 1
                [[102, 102, 102], "11110101110"],
                // Start Code A
                [[103, 103, 103], "11010000100"],
                // Start Code B
                [[104, 104, 104], "11010010000"],
                // Start Code C
                [[105, 105, 105], "11010011100"],
                // Stop
                [[106, 106, 106], "11000111010"],
                // Reverse Stop
                [[107, 107, 107], "11010111000"],
                // Stop pattern (7 bars/spaces)
                [[108, 108, 108], "1100011101011"],
            ]

            constructor(){
                // code39 characters are separated by an additional narrow space.
                this.code39_raw.forEach((set)=>{
                    let [code, pattern] = set;
                    if (!pattern.endsWith('1')){throw new Error('Code39 data pattern error')}
                    this.code39[code] = pattern + "0"
                })

                this.code128_raw.forEach((set, i)=>{
                    let [[a,b,c], p] = set;
                    this.code128.a[a] = p;
                    this.code128.b[b] = p;
                    this.code128.c[c] = p;
                    this.code128.p_i[p] = i;
                    this.code128.i_p[i] = p;
                })
            }

            patternToWidth(pattern){
                return pattern.match(/(.)\1*/g).map((x)=>x.length).join(' ')
            }

            charToWidth(cha, codeset){
                if (codeset == undefined){
                    cha = cha.toUpperCase();
                    codeset = this.code39;
                }

                if (cha in codeset === false){
                    throw new Error(`character '${cha}' not in selected codeset!`);
                }
                return this.patternToWidth(codeset[cha]);
            }

            textToWidth(text, codeset){
                return text.split('').map((x)=>this.charToWidth(x, codeset)).join(' ');
            }

            textToCode128B(text){
                if (!/[\x20-\x7F\xC8-\xCF]/.test(text)){
                    throw new Error(`text '${text}' is not encodable to code128b`);
                }

                // start with 104, the start code of 128b
                let check_total = text.split("").reduce((p, x, i)=>p+this.code128.p_i[this.code128.b[x]]*(i+1), 104);

                return [this.patternToWidth(this.code128.b[104]),
                this.textToWidth(text, this.code128.b),
                this.patternToWidth(this.code128.i_p[check_total%103]),
                this.patternToWidth(this.code128.b[108])].join(' ')
            }

            textToCode39(text){
                if (/[^0-9A-Z\-\.\ \$\/\+\%]/.test(text)){
                    throw new Error(`text '${text}' is not encodable to code39`);
                }

                let s = this.patternToWidth('1001011011010');
                return [s, this.textToWidth(text, this.code39), s].join(' ')
            }

            dashArrayToSVG(dasharray){
                let len = dasharray.split(' ').reduce((p,x)=>p+parseInt(x),0);

                let svg = document.getElementById('svg_barcode_template').cloneNode(true);
                svg.removeAttribute('id');
                let line = svg.children[0];
                line.setAttribute('x2', len);
                line.setAttribute('transform',`matrix(${320/len} 0 0 100 0 0)`);
                line.setAttribute('stroke-dasharray', dasharray);
                return svg
            }
        }

        class Loader{
            constructor(bingo){
                this.bingo = bingo;
                this.init_ui();
            }

            init_ui(){
                let loader_button = document.getElementById("loader_button");
                loader_button.onclick = ()=>{
                    this.bingo.cards.serializer.from_card_id(document.getElementById("card_loader").value);
                }
            }
        }
        bingo = new Bingo();

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register("sw-offline.js");
        }
    </script>

</body>
</html>
