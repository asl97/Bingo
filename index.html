<!DOCTYPE html>
<html>
<body>

    <style>
        body {
            display: flex;
            place-content: center;
        }
        body[data-view="bingo spinner"] #bingo_wrapper,
        body[data-view="amount selector"] #amount_wrapper,
        body[data-view="cards editor"] #card_editor_wrapper,
        body[data-view="card printer"] #printer_wrapper,
        body[data-view="card verify and loader"] #verify_and_loader_wrapper {
            display: flex;
        }

        body[data-view="bingo spinner"] .card_control,
        #amount_wrapper, #bingo_wrapper, #card_editor_wrapper,
        #printer_wrapper, #verify_and_loader_wrapper {
            display: none;
        }

        #amount_wrapper, #bingo_wrapper, #card_editor_wrapper, #printer_wrapper {
            flex-direction: column;
            place-items: center;
            text-align: center;
            width: 60%;
        }

        #bingo_wrapper > #number_display {
            font-size: 5vw;
        }

        #start_button{
            margin-top: 2vw;
            font-size: 5vw;
        }

        #content, #number_selector, #active_card {
            display:table;
            width: 100%;
            font-size: 2vw;
            touch-action: manipulation;
            border-collapse: collapse;
            border: 1px solid black;
            text-align: center;
        }
        #number_display {
            margin: 0;
        }
        .top {
            display: grid;
            grid-template-columns: 1fr 1fr;
            position: absolute;
            top: 0;
        }
        .top span {
            padding: 0.5vw 1vw;
            border-bottom: 1px solid black;
        }
        .left {
            left: 0;
            flex-direction: column;
        }
        .left span {
            border-right: 1px solid black;
        }
        .left > * {
            display: flex;
        }
        .right {
            right: 0;
        }
        .right > span {
            border-left: 1px solid black;
        }
        .table_row {
            display: table-row;
            border: 1px solid black;
        }
        .table_cell {
            display: table-cell;
            border: 1px solid black;
            padding: 0;
            vertical-align: middle;
        }
        .chosen {
            background-color: lightgreen;
        }
        .number_input {
            font-size: 10vw;
            width: 1em;
        }
        .row {
            display: flex;
        }

        #cards_wrapper,
        #bingo_wrapper .add_card {
            display: none;
        }

        #card_editor_wrapper > #cards_wrapper,
        #bingo_wrapper > #cards_wrapper {
            touch-action: manipulation;
            display: flex;
        }

        #active_card .table_cell > input {
            width: 5vw;
            border: 0;
            padding: 0;
            outline: none;
            font-size: 2vw;
            text-align: center;
        }

        #card_editor_wrapper > * {
            margin: 1vw;
        }

        #card_editor {
            display: flex;
        }
        .card_button {
            display: flex;
            place-content: center;
            border: black solid;
            margin: 0 1vw;
            width: 5vw;
        }

        .card {
            touch-action: manipulation;
            border: black solid;
            margin: 1vw;
            height: 18vw;
            width: 18vw;
            display:table;
            text-align: center;
            font-size: 2vw;
        }

        .card_control {
            display: flex;
            place-content: center;
        }

        .card_control > .card_button {
            margin: 0 0.2vw;
        }

        #card_template {
            display: none;
        }
    </style>

    <div class='top left'>
        <span id='reset_button'>reset</span>
        <span id='change_amount'>change amount</span>
        <span id='spinner_button'>spinner</span>
        <span id='cards_editor_button'>bingo card</span>
        <span id='printer_button'>card printer</span>
        <span id='verify_load_button'>verify/load card</span>
        </div>
    </div>

    <div class='top right'>
        <span id='mute_button'>mute</span>
        <span id='fullscreen'>fullscreen</span>
    </div>

    <div id='amount_wrapper'>
        <h1>Bingo Number Roller Caller</h1>
        <div id='amount_input'></div>
        <button id='start_button'>Start!</button>
    </div>

    <div id='bingo_wrapper'>
        <h1 id="number_display">Click</h1>
        <div id="content"></div>
    </div>

    <div id='card_editor_wrapper'>
        <h1>Card Editor</h1>
        <div id='card_editor'>
            <div style='display:grid;'>
                <div id='randomize_card_editor' class='card_button'>
                    <svg viewBox='0 0 16 16'>
                        <path d="M1,11 L5,11 L9,5 L14,5 L10,2" stroke="black" fill="none"></path>
                        <path d="M1,5 L5,5 L9,11 L14,11 L10,14" stroke="black" fill="none"></path>
                    </svg>
                </div>
                <div id='clear_card_editor' class='card_button'>
                    <svg viewBox='0 0 16 16'>
                        <path d='M1,8 L15,8' stroke='black' fill='none'></path>
                    </svg>
                </div>
            </div>
            <div id='active_card'></div>
            <div id='add_card_editor' class='card_button'>
                <svg viewBox='0 0 16 16'>
                    <path d='M1,8 L15,8' stroke='black' fill='none'></path>
                    <path d='M8,1 L8,15' stroke='black' fill='none'></path>
                </svg>
            </div>
        </div>
        <div id='number_selector'></div>
    </div>

    <div id='printer_wrapper'>
        <h1>Card Printer</h1>
        <div style='display:flex;'>
            <div id='prev_card' class='card_button'>
                <svg viewBox='0 0 16 16'>
                    <path d="M14,2 L2,8 L 14,14" stroke="black" fill="none"></path>
                </svg>
            </div>
            <div>
                <div id='printer_card' style="text-align: center; display:grid; place-content:center;">
                    <div>
                        <label>Card id: </label><label id='card_id'></label>
                    </div>
                    <div id='card_viewer'></div>
                </div>
                <button id='print_button'>Print</button>
            </div>
            <div id='next_card' class='card_button'>
                <svg viewBox='0 0 16 16'>
                    <path d='M2,2 L14,8 L2,14' stroke='black' fill='none'></path>
                </svg>
            </div>
        </div>
    </div>

    <div id='verify_and_loader_wrapper'>
        <label>Card id:</label><input id='card_loader'>
        <div id='card_loader_viewer'></div>
        <button id='loader_button'>Load</button>
    </div>

    <div id='cards_wrapper'>
    </div>

    <div id='card_template'>
        <div class='card_control'>
            <div class='card_button move_card_left'>
                <svg viewBox='0 0 16 16'>
                    <path d='M14,2 L2,8 L 14,14' stroke='black' fill='none'></path>
                </svg>
            </div>
            <div>
                <div class='card_button edit_card'>
                    <svg viewBox='0 0 16 8'>
                        <path d='M2,6 L8,2 L14,6' stroke='black' fill='none'></path>
                    </svg>
                </div>
                <div class='card_button delete_card'>
                    <svg viewBox='0 0 16 8'>
                        <path d='M2,2 L14,6' stroke='black' fill='none'></path>
                        <path d='M2,6 L14,2' stroke='black' fill='none'></path>
                    </svg>
                </div>
            </div>
            <div class='card_button move_card_right'>
                <svg viewBox='0 0 16 16'>
                    <path d='M2,2 L14,8 L2,14' stroke='black' fill='none'></path>
                </svg>
            </div>
        </div>
        <div class='card_content'></div>
        <label>Card ID: </label><label class='card_id'></label>
    </div>

    <dialog id='alert'>
        <p></p>
    </dialog>

    <script>
        /*
            cyrb53 (c) 2018 bryc (github.com/bryc)
            A fast and simple hash function with decent collision resistance.
            Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
            Public domain. Attribution appreciated.
        */
        class bryc{
            static cyrb128(str) {
                let h1 = 1779033703, h2 = 3144134277,
                    h3 = 1013904242, h4 = 2773480762;
                for (let i = 0, k; i < str.length; i++) {
                    k = str.charCodeAt(i);
                    h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
                    h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
                    h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
                    h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
                }
                h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
                h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
                h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
                h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
                return [(h1^h2^h3^h4)>>>0, (h2^h1)>>>0, (h3^h1)>>>0, (h4^h1)>>>0];
            }
        }
    </script>
    <script>
        // I, Chris Doty-Humphrey, release all of my work on PractRand to the public domain. 
        // https://pracrand.sourceforge.net/license.txt
        // sfc* was designed and coded by myself, and is public domain.  

        // ported by bryc
        // (c) 2018 bryc (github.com/bryc)
        // Public domain. Attribution appreciated.
        class PractRand{
            static sfc32(a, b, c, d) {
                return function() {
                a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
                var t = (a + b) | 0;
                a = b ^ b >>> 9;
                b = c + (c << 3) | 0;
                c = (c << 21 | c >>> 11);
                d = d + 1 | 0;
                t = t + d | 0;
                c = c + t | 0;
                return (t >>> 0) / 4294967296;
                }
            }
        }
    </script>
    <script>
        // Base on this stackoverflow answer from Rafael Lima
        // Licensed CC BY-SA 4.0 (mentioned in share menu)
        // https://stackoverflow.com/a/69549596/1986995

        // Fixed the edge case bug
        class base_convert{
            static alphabet = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';

            static to_radix = function(bigNum, radix=64) {
                if(typeof bigNum != 'bigint')
                bigNum = BigInt(bigNum);

                radix = BigInt(Math.max(Math.min(radix, this.alphabet.length),0))

                let result = '';
                while (bigNum>0) {
                    let r = bigNum % radix;
                    result = this.alphabet[r] + result;
                    bigNum = bigNum / radix;
                } 
                return result
            }

            static from_radix = function(input, radix=64) {
                if(!input)
                    return 0;

                radix = BigInt(Math.max(Math.min(radix, this.alphabet.length),0))

                var result = 0n;

                for (var i = 0; i < input.length; i++)
                    result = (result * BigInt(radix)) + BigInt(this.alphabet.indexOf(input[i]));

                return result;
            }
        }
    </script>
    <script>
        // Base on this stackoverflow answer marked community wiki
        // Licensed CC BY-SA 4.0 (mentioned in share menu)
        // https://stackoverflow.com/a/6274398/1986995
        function seeded_shuffle(array, seed) {
            let random_generator = PractRand.sfc32(...bryc.cyrb128(seed));
            let counter = array.length;

            // While there are elements in the array
            while (counter > 0) {
                // Pick a random index
                let index = Math.floor(random_generator() * counter);

                // Decrease counter by 1
                counter--;

                // And swap the last element with it
                let temp = array[counter];
                array[counter] = array[index];
                array[index] = temp;
            }

            return array;
        }
    </script>
    <script>
        const View_states = {
            Bingo: 'bingo spinner',
            Amount: 'amount selector',
            Cards: 'cards editor',
            Printer: 'card printer',
            Verify: 'card verify and loader'
        };
        Object.freeze(View_states);

        function create_svg_icon(size, path){
            let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg")
            svg.setAttribute('viewBox', size);

            let path_element = document.createElementNS("http://www.w3.org/2000/svg", "path")
            path_element.setAttribute('d',path);
            path_element.setAttribute('stroke','black')
            path_element.setAttribute('fill', 'none')
            path_element.setAttribute('stroke-linejoin', 'round')

            svg.appendChild(path_element);
            return svg
        }

        function shuffle(array) {
            let currentIndex = array.length, temporaryValue, randomIndex;

            // While there remain elements to shuffle...
            while (0 !== currentIndex) {
            // Pick a remaining element...
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex --;

                // And swap it with the current element.
                temporaryValue = array[currentIndex];
                array[currentIndex] = array[randomIndex];
                array[randomIndex] = temporaryValue;
            }
        }

        class SpeechQueue {
            constructor(){
                this._queue = [];
                this.speaking = false;
            }

            queue(text){
                this._queue.unshift(text);
                this.speak();
            }

            speak(){
                if (this.speaking || !this._queue.length) return
                this.speaking = true;
                let text = this._queue.pop();
                let utter = new SpeechSynthesisUtterance(text);
                utter.onend = ()=>{
                    setTimeout(()=>{
                        this.speaking = false;
                        this.speak();
                    }, 300)
                }
                speechSynthesis.speak(utter);
            }

            cancel(){
                this._queue.length = 0;
                speechSynthesis.cancel();
            }
        }

        let speechqueue = new SpeechQueue();

        class Roll {
            constructor(bingo, number_elements){
                this.bingo = bingo;
                this.end_roll_time;
                shuffle(number_elements);
                this.numbers = number_elements;
                this.spinning = false;
            }

            unroll_element(element){
                element.classList.remove("chosen");
                let number = element.textContent;
                this.bingo.cards.unroll(number);
                this.numbers.push(element);
                shuffle(this.numbers);
            }

            roll(number, muted){
                let number_display = document.getElementById('number_display');
                number_display.textContent = number;

                if (!muted) {
                    number = parseInt(number).toString();
                    for (let text of [number, ...number]){
                        speechqueue.queue(text);
                    }
                }
            }

            roll_element(element, muted){
                if (muted === undefined)
                    muted = this.bingo.muted
                element.classList.add('chosen');
                this.numbers.splice(this.numbers.indexOf(element), 1);
                let number = element.textContent;
                this.roll(number, muted);
                this.bingo.cards.roll(number);
            }

            animated_roll(){
                if (!this.numbers.length){
                    this.spinning = false;
                    return
                }

                let number;
                if (performance.now() < this.end_roll_time){
                    let index = Math.floor(Math.random() * this.numbers.length);
                    number = this.numbers[index].textContent;
                    this.roll(number, true);
                    requestAnimationFrame(()=>this.animated_roll());
                } else {
                    let element = this.numbers[0];
                    this.spinning = false;
                    this.roll_element(element);
                }


            }
            start_animated_roll(){
                if (this.spinning) return
                this.spinning = true;
                if (this.numbers.length > 1) this.end_roll_time = performance.now()+1500;
                this.animated_roll();
            }
        }

        class Bingo{
            constructor(){
                this.inputs = [];
                this.muted = false;
                this.roll_instance;
                this.url = new URL(window.location.href);
                this.cards = new Cards(this);
                this.cards.observe();
                this.printer = new Printer(this);
                this.loader = new Loader(this);
                this.init_ui()
                this.post_init_ui();
            }

            bind_input_handler(up, input, down){
                // Set outer `last_input` to local next_input
                // So it doesn't change for the local scope
                let next_input = this.inputs[this.inputs.length-1];
                let check_input = function(){
                    // If less than 0, decrease next number
                    while (input.value < 0) {
                        input.value = +input.value + 10;
                        if (next_input){
                            next_input.stepDown()
                            next_input.oninput()
                        };
                    }
                    // If more than 9, increase next number
                    while (input.value > 9) {
                        input.value = +input.value - 10;
                        if (next_input){
                            next_input.stepUp();
                            next_input.oninput()
                        }
                    }
                }
                input.oninput = check_input;
                up.onclick = ()=>{input.stepUp(); input.oninput()};
                down.onclick = ()=>{input.stepDown(); input.oninput()};

                this.inputs.push(input);
            }

            create_input_number(){
                let up, input, down;

                up = create_svg_icon('0 0 16 8', 'M1,7 L8,1 L15,7'); //'︿'

                input = document.createElement('input');
                input.classList.add('number_input');
                input.type='number';
                input.value = 0;

                down = create_svg_icon('0 0 16 8', 'M1,1 L8,7 L15,1'); //'﹀'

                this.bind_input_handler(up, input, down)

                return [up, input, down];
            }

            generate_amount_input(){
                let amount_input = document.getElementById('amount_input');

                let columns = [];
                let rows = [];

                // Create the three row, up button row, input row, down button row
                for (let i=0; i<3; i++){
                    let row = document.createElement('div');
                    row.classList.add('row');
                    rows.push(row)
                }

                // create the amount of input wanted
                let max_number = 999
                let number_of_digit = Math.log10(max_number)+1|0
                for (let i=0; i<number_of_digit; i++){
                    let number_column = this.create_input_number();
                    columns.push(number_column);
                }

                // columns to rows
                // layman terms: for first row, append first item in columns, etc etc
                for (let i=0; i<rows.length; i++){
                    for (let column of columns){
                        rows[i].appendChild(column[i])
                    }
                }

                // Append each row to the amount input interface
                for (let row of rows){
                    amount_input.appendChild(row);
                }
            }

            generate_numbers_display(numbers){
                let content = document.getElementById('content')
                content.innerHTML = '';
                let number = 0 ;
                let number_elements = [];
                let number_length = Math.floor(Math.log10(numbers)) + 1;

                while (number < numbers){
                    let row = document.createElement('div')
                    row.classList.add('table_row');
                    for (let i=0; i<10; i++){
                        number++;
                        if (number > numbers) break;
                        let span = document.createElement('span');
                        span.textContent = number.toString().padStart(number_length, '0');
                        span.classList.add('table_cell');
                        span.onclick = ()=>{
                            if (span.classList.contains("chosen")){
                                this.roll_instance.unroll_element(span);
                            } else {
                                this.roll_instance.roll_element(span);
                            }
                        };
                        row.appendChild(span);
                        number_elements.push(span);
                    }
                    content.appendChild(row);
                }

                return number_elements;
            }

            get_input_number(){
                let res = "";
                for (let input of this.inputs){
                    res += input.value;
                }
                return parseInt(res);
            }

            update_url(){
                this.url.searchParams.set("amount", this.get_input_number());
                window.history.replaceState('', '', this.url.href);
            }

            start(){
                this.update_url();
                this.cards.reset();
                let number_elements = this.generate_numbers_display(this.get_input_number());
                this.roll_instance = new Roll(this, number_elements);
                document.body.dataset.view=View_states.Bingo;
                let number_display = document.getElementById('number_display');
                number_display.textContent = 'Click';
            }

            change_amount(){
                document.body.dataset.view=View_states.Amount;
            }

            cards_editor(){
                this.update_url();
                document.body.dataset.view=View_states.Cards;
            }

            bingo_spinner(){
                document.body.dataset.view=View_states.Bingo;
            }

            printer_button(){
                this.printer.update_ui();
                document.body.dataset.view=View_states.Printer;
            }

            verify_and_loader(){
                document.body.dataset.view=View_states.Verify;
            }

            mute(){
                let mute_button = document.getElementById('mute_button');
                if (!this.muted){
                    speechqueue.cancel();
                    this.muted = true;
                    mute_button.style['background-color'] = 'red';
                } else {
                    this.muted = false;
                    mute_button.style['background-color'] = '';
                }
            }

            init_ui(){
                let mute_button = document.getElementById('mute_button');
                mute_button.onclick = ()=>this.mute();

                let fullscreen_button = document.getElementById('fullscreen');
                fullscreen_button.onclick = function(){
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        document.documentElement.requestFullscreen();
                    }
                }

                let alert = document.getElementById('alert');
                alert.onclick = ()=>alert.close();

                this.generate_amount_input();
                let last_input = this.inputs[this.inputs.length-1];
                last_input.value = this.url.searchParams.get("amount") || 90;
                last_input.oninput();

                let start_button = document.getElementById('start_button');
                start_button.onclick = ()=>this.start();

                let reset_button = document.getElementById('reset_button');
                reset_button.onclick = ()=>this.start();

                let change_amount_button = document.getElementById('change_amount');
                change_amount_button.onclick = ()=>this.change_amount();

                let cards_editor_button = document.getElementById('cards_editor_button');
                cards_editor_button.onclick = ()=>this.cards_editor();

                let spinner_button = document.getElementById('spinner_button');
                spinner_button.onclick = ()=>this.bingo_spinner();

                let printer_button = document.getElementById('printer_button');
                printer_button.onclick = ()=>this.printer_button();

                let verify_load_button = document.getElementById('verify_load_button');
                verify_load_button.onclick = ()=>this.verify_and_loader();

                let roll_button = document.getElementById('number_display');
                roll_button.onclick = ()=>this.roll_instance.start_animated_roll();
            }

            post_init_ui(){
                this.start();
                document.body.dataset.view=View_states.Amount;
            }
        }

        class Cards{
            constructor(bingo){
                this.bingo = bingo;
                this.width = 5;
                this.height = 5;
                this.slots = this.width*this.height;
                this.init_ui();
            }

            serializer = {
                to_arrays: function (c){return function* _(){
                    for (let row of c.getElementsByClassName('table_row')){
                        yield function* (r){
                            for (let span of r.getElementsByTagName('span')){
                                let number = span.textContent;
                                if (number === "*")
                                    number = '0'
                                yield parseInt(number);
                            }
                        }(row);
                    }
                }},

                to_card_id: (card)=>{
                    let data = '';
                    let numbers = [];
                    let max_number = 0;
                    
                    for (let row of card){
                        for (let number of row){
                            numbers.push(number);

                            if (number > max_number)
                                max_number = number;
                        }
                    }

                    let digits = Math.floor(Math.log10(max_number)) + 1;
                    for (let number of numbers){
                        data += number.toString().padStart(digits, '0');
                    }
                    return base_convert.to_radix(data);

                },

                from_card_id: (card_id)=>{
                    alert(card_id.split(/(?:\s+)/).length);
                    if (card_id.startsWith("CS-")){
                        // TODO
                    } else if (card_id.split(/(?:\s+)/).length == this.slots) {
                        // number of numbers match expected bingo card
                        // for support of using google len or OCR to load physical card
                        alert(card_id);
                    } else {
                        //alert(card_id);
                    }
                },

                compact: (card)=>{
                    let data = 0n;
                    let numbers = [];
                    let max_number = 0n;
                    for (let row of card){
                        for (let number of row){
                            number = BigInt(number);
                            numbers.push(number);

                            if (number > max_number)
                                max_number = number;
                        }
                    }

                    max_number += 1n
                    for (let number of numbers){
                        data = data * max_number + number;
                    }

                    return max_number.toString()+"d"+data.toString()
                },

                uncompact: (data)=>{
                    let [max_digit, ...data_array] = data.split('d');
                    max_digit = BigInt(max_digit);
                    let bigNum = BigInt(data_array.join(''));

                    let result = [];
                    while (bigNum>0) {
                        result.push(bigNum % max_digit);
                        bigNum = bigNum / max_digit;
                    }

                    return result.reverse();
                },

            }

            to_arrays_with_seed(card){
                let card_id = card.getElementsByClassName('card_id')[0].textContent;
                return [card_id, this.serializer.to_arrays(card.getElementsByClassName('card')[0])]
            }

            get_cards(){
                let cards_wrapper = document.getElementById('cards_wrapper');
                let cards = cards_wrapper.children;
                return Array.from(cards).map(this.to_arrays_with_seed.bind(this));
            }

            generate_active_card(){
                let active_card = document.getElementById('active_card');

                for (let i=0; i<this.height; i++){
                    let row = document.createElement('div');
                    row.classList.add('table_row');
                    for (let l=0; l<this.width; l++){
                        let input_div = document.createElement('div');
                        let input = document.createElement('input');
                        input_div.appendChild(input);
                        input_div.classList.add('table_cell');
                        input_div.onclick = ()=>input.focus();
                        row.appendChild(input_div);
                    }
                    active_card.appendChild(row);
                }
            }

            randomize_array(seed){
                let numbers = [];
                for (let i=1; i<=this.bingo.get_input_number(); i++){
                    numbers.push(i);
                }

                seeded_shuffle(numbers, seed);
                return numbers
            }

            randomize_active_card(){
                let seed = Math.floor(Math.random()*9999).toString();
                let numbers = this.randomize_array(seed)
                let card_id = document.getElementById('card_id');
                card_id.textContent = "CS-"+seed;

                let index = 0;
                let active_card = document.getElementById('active_card');
                for (let input of active_card.getElementsByTagName('input')){
                        input.value = numbers[index];
                        index++;
                }
            }

            clear_active_card(){
                let active_card = document.getElementById('active_card');
                for (let input of active_card.getElementsByTagName('input')){
                        input.value = '';
                }
            }

            load_card_to_editor(card){
                let alert = document.getElementById('alert');
                let active_card = document.getElementById('active_card');
                let inputs = active_card.getElementsByTagName('input');
                for (let input of inputs){
                        if (input.value !== ''){
                            alert.getElementsByTagName('p')[0].textContent = "Card editor is not empty";
                            alert.showModal();
                            return
                        }
                }

                let index = 0;
                for (let span of card.getElementsByTagName('span')){
                    inputs[index].value = span.textContent;
                    index++
                }

                card.parentElement.parentElement.remove();
            }

            generate_card(arr){
                let alert = document.getElementById('alert');
                let card = document.createElement('div');
                card.classList.add('card');

                let index = 0;
                for (let i=0; i<this.height; i++){
                    let row = document.createElement('div');
                    row.classList.add('table_row');
                    for (let l=0; l<this.width; l++){
                        let span = document.createElement('span');
                        let value = arr[index];
                        if (value === '' || value === '*' || value === '0'){
                            span.textContent = '*';
                        } else if (!isNaN(parseInt(value))) {
                            if (parseInt(value) < 0){
                                alert.getElementsByTagName('p')[0].textContent = "Card editor contains a number less than 1";
                                alert.showModal();
                                return
                            } else if (parseInt(value) > this.bingo.get_input_number()){
                                alert.getElementsByTagName('p')[0].textContent = "Card editor contains a number greater than "+this.bingo.get_input_number();
                                alert.showModal();
                                return
                            } else {
                                span.textContent = value;
                            }
                        } else {
                            alert.getElementsByTagName('p')[0].textContent = "Card editor contains non number";
                            alert.showModal();
                            return
                        }
                        
                        span.onclick = ()=>this.click_roll(span);
                        span.classList.add('table_cell');
                        row.appendChild(span);
                        index++;
                    }
                    card.appendChild(row);
                }

                return card
            }

            generate_and_add_card(){
                let card_template = document.getElementById('card_template');

                let active_card = document.getElementById('active_card');
                let inputs = active_card.getElementsByTagName('input');
                let arr = Array.from(inputs).map((x)=>x.value);
                let card = this.generate_card(arr)

                let card_wrapper = card_template.cloneNode(true);
                card_wrapper.removeAttribute('id');
                let card_content = card_wrapper.getElementsByClassName('card_content')[0];
                card_content.appendChild(card);

                let move_left = card_wrapper.getElementsByClassName('move_card_left')[0];
                move_left.onclick = ()=>card_wrapper.parentElement.insertBefore(card_wrapper, card_wrapper.previousSibling);
                let move_right = card_wrapper.getElementsByClassName('move_card_right')[0];
                move_right.onclick = ()=>{
                    if (card_wrapper.nextSibling) {
                        card_wrapper.parentElement.insertBefore(card_wrapper, card_wrapper.nextSibling.nextSibling);
                    } else {
                        card_wrapper.parentElement.prepend(card_wrapper);
                    }
                    
                };
                let edit_button = card_wrapper.getElementsByClassName('edit_card')[0];
                edit_button.onclick = ()=>this.load_card_to_editor(card);
                let delete_button = card_wrapper.getElementsByClassName('delete_card')[0];
                delete_button.onclick = ()=>card_wrapper.remove();

                // Verify seeded random number isn't edited
                let card_id = document.getElementById('card_id');
                if (card_id.textContent.startsWith("CS-")){
                    let all_match = true;
                    let ra = this.randomize_array(card_id.textContent.slice(3));
                    for (let i=0; i<inputs.length; i++){
                        let value = inputs[i].value;
                        if (value === '' || value === '*' || ra[i] != parseInt(value)){
                            all_match = false;
                            break;
                        }
                    }

                    if (all_match){
                        card_wrapper.getElementsByClassName('card_id')[0].textContent = card_id.textContent;
                    }

                }

                return card_wrapper;
            }

            mark_rolled_number(card){
                let content = document.getElementById('content');
                let rolled = new Set();
                rolled.add("*");
                for (let chosen of content.getElementsByClassName('chosen')){
                    rolled.add(parseInt(chosen.textContent));
                }

                for (let slot of card.getElementsByTagName('span')){
                    let value = !isNaN(parseInt(slot.textContent)) ? parseInt(slot.textContent) : slot.textContent;
                    if (rolled.has(value)){
                        slot.classList.add('chosen');
                    }
                }
            }

            add_card(){
                let cards = document.getElementById('cards_wrapper');
                let card_wrapper = this.generate_and_add_card();
                this.mark_rolled_number(card_wrapper);

                cards.appendChild(card_wrapper);
                this.clear_active_card();
            }

            init_ui(){
                this.generate_active_card();

                let active_card = document.getElementById('active_card');

                let random_button = document.getElementById('randomize_card_editor');
                random_button.onclick = ()=>this.randomize_active_card();
                let clear_button = document.getElementById("clear_card_editor");
                clear_button.onclick = ()=>this.clear_active_card();

                let add_button = document.getElementById('add_card_editor');
                add_button.onclick = ()=>this.add_card();
            }

            update_ui(){
                let content = document.getElementById('number_selector');
                content.innerHTML = '';
                let number = 0;
                let numbers = this.bingo.get_input_number();
                let number_elements = [];
                let number_length = Math.floor(Math.log10(numbers)) + 1;

                while (number < numbers){
                    let row = document.createElement('div');
                    row.classList.add('table_row');
                    for (let i=0; i<10; i++){
                        number++;
                        if (number > numbers) break;
                        let span = document.createElement('span');
                        span.textContent = number.toString().padStart(number_length, '0');
                        span.classList.add('table_cell');
                        // allow clicking number to fill the next empty slot
                        span.onclick = ()=>{
                            let active_card = document.getElementById('active_card');
                            for (let input of active_card.getElementsByTagName('input')){
                                if (input.value === ''){
                                    input.value = span.textContent;
                                    return
                                }
                            }
                        };
                        row.appendChild(span);
                        number_elements.push(span);
                    }
                    content.appendChild(row);
                }

                return number_elements;
            }

            reset(){
                let cards = document.getElementById('cards_wrapper');
                let slots = cards.getElementsByClassName('chosen');
                while (slots.length){
                    slots[0].classList.remove('chosen');
                }
            }

            unroll(number){
                let cards = document.getElementById('cards_wrapper');
                for (let slot of cards.getElementsByTagName('span')){
                    if (parseInt(slot.textContent) == parseInt(number)){
                        slot.classList.remove('chosen');
                    }
                }
            }
            roll(number){
                let cards = document.getElementById('cards_wrapper');
                for (let slot of cards.getElementsByTagName('span')){
                    if (parseInt(slot.textContent) == parseInt(number)){
                        slot.classList.add('chosen');
                    }
                }
            }

            click_roll(element){
                if (isNaN(parseInt(element.textContent))) return;
                for (let span of document.getElementById('content').getElementsByTagName('span')){
                    if (parseInt(span.textContent) == parseInt(element.textContent)){
                        span.click();
                    }
                }
            }

            observe(){
                const cards_element = document.getElementById('cards_wrapper');
                const config = { attributes: true, childList: false, subtree: false };

                // Callback function to execute when mutations are observed
                const callback = (mutationList, observer) => {
                    for (const mutation of mutationList) {
                        if (mutation.type === 'attributes' & mutation.attributeName==="data-view") {
                            if (mutation.target.dataset.view === View_states.Bingo){
                                document.getElementById('bingo_wrapper').appendChild(cards_element);
                            } else if (mutation.target.dataset.view == View_states.Cards){
                                document.getElementById('card_editor_wrapper').appendChild(cards_element);
                                this.update_ui();
                            }
                        }
                    }
                };

                // Create an observer instance linked to the callback function
                this.observer = new MutationObserver(callback);

                // Start observing the target node for configured mutations
                this.observer.observe(document.body, config);
            }
        }

        class Printer{
            constructor(bingo){
                this.bingo = bingo;
                this.init_ui();
            }

            init_ui(){
                let print_button = document.getElementById('print_button');
                print_button.onclick = ()=>{
                    this.print()
                }
                
            }

            print(){
                var divContents = document.getElementById("printer_card").outerHTML;
                var a = window.open('', '', 'height=500, width=500');
                a.document.write('<html><body>'+divContents+'</body></html>');
                a.document.close();
                a.print();
            }

            update_ui(){
                let cards = this.bingo.cards.get_cards();

                if (cards.length === 0) {
                    let card_viewer = document.getElementById('card_viewer');
                    card_viewer.textContent = "No card added yet";
                } else {
                    this.load(cards[0]);
                }
            }

            load(card){
                let [card_id_str, card_content_factory] = card;
                if (card_id_str == "")
                    card_id_str = this.bingo.cards.serializer.to_card_id(card_content_factory());

                let card_id = document.getElementById('card_id');
                card_id.textContent = card_id_str;

                let arr = [];
                for (let row of card_content_factory())
                    for (let number of row)
                        arr.push(number.toString());

                let card_ele = this.bingo.cards.generate_card(arr);
                card_ele.style['font-size'] = '6vw'
                for (let row of card_ele.children){
                    row.style.display = 'table-row';
                    row.style.border = '1px black solid';
                    for (let c of row.children){
                        c.style.display = 'table-cell';
                        c.style.border = '1px black solid';
                        c.style.padding = '1vw';
                        c.style['vertical-align'] = 'middle';
                    }
                }

                document.getElementById('card_viewer').innerHTML = card_ele.outerHTML;
            }

        }

        class Loader{
            constructor(bingo){
                this.bingo = bingo;
                this.init_ui();
            }

            init_ui(){
                let loader_button = document.getElementById("loader_button");
                loader_button.onclick = ()=>{
                    this.bingo.cards.serializer.from_card_id(document.getElementById("card_loader").value);
                }
            }
        }
        bingo = new Bingo();

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register("sw-offline.js");
        }
    </script>

</body>
</html>
